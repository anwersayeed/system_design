# üçî Uber Eats System Design (Focused on Search, Driver Matching, Payments)

---

## 1 ‚Äî Clarify Scope & Requirements

### **Scope chosen**
- Search (restaurants & food)
- Driver matching (after order is ready)
- Customer payments  
*(not including driver payouts)*

---

## **Functional Requirements**
- Customers can search restaurants / dishes.
- Customers can place orders.
- Drivers receive order notifications / get matched.
- System can process customer payments.

---

## **Non-Functional Requirements**
- Low search latency (~hundreds of ms).
- High availability.
- Strong consistency for:
  - driver matching  
  - payments  
- Eventual consistency acceptable for menu/search freshness.
- Scale across the US ‚Üí assume **regional sharding**.

---

# 2 ‚Äî High-Level Architecture (Microservices)

### **API / Load Balancer Layer**
- Receives client traffic  
- Routes to appropriate microservice

---

## **Microservices**
- **Search service** ‚Äî queries Elasticsearch for restaurant/dish search.
- **Order service** ‚Äî creates orders (SQL).
- **Payment service** ‚Äî handles customer payments (Stripe-like third party).
- **Delivery / Driver Matching service** ‚Äî selects and assigns drivers.
- **Driver session / realtime service** ‚Äî maintains driver WebSocket connections.
- **Notification service** ‚Äî pushes notifications to customers/drivers.

---

## **Datastores**
- **Restaurant & Menu DB:** NoSQL (horizontal scalability).
- **Search Index:** Elasticsearch for fast, low-latency text search.
- **Order DB:** SQL (ACID) for correctness of money & order states.
- **Driver Location Store:** geo-optimized datastore for frequent writes.
- **Driver‚ÄìOrder Mapping Store:** fast, atomic store guaranteeing 1:1 assignment.

---

# 3 ‚Äî Customer Search Flow

1. Client ‚Üí Load Balancer ‚Üí Search Service.
2. Search Service queries **Elasticsearch**.
3. Elasticsearch is kept updated via **periodic sync** from menu DB.
4. Results returned to client.

**Trade-off:**  
- Elasticsearch ‚Üí very low latency  
- Accept **eventual consistency** on menu updates  
- Reindex frequency determines freshness SLA  

---

# 4 ‚Äî Order Placement & Payments

### **Flow**
1. Customer selects items ‚Üí sends request ‚Üí Order Service.
2. Order Service:
   - creates order entry (PENDING) in SQL Order DB.
3. Order Service calls Payment Service **synchronously**.
4. Payment Service (via Stripe-like provider):
   - charges user  
   - returns result  
5. On success ‚Üí Order Service updates status to **PAID**.  
6. On failure ‚Üí return error, order not confirmed.

---

### **Idempotency**
- Client generates **idempotency key**.
- Stored by Order/Payment Services.
- Prevents:
  - double charges  
  - duplicate orders  

---

# 5 ‚Äî From Restaurant ‚ÄúOrder Ready‚Äù ‚Üí Driver Assignment

1. Restaurant marks order as **READY**.
2. Event emitted ‚Üí **Delivery/Driver Matching Service**.
3. Matching service:
   - reads nearby online drivers from Driver Location Store.
   - applies proximity + heuristic filtering.
4. Service selects candidate drivers.
5. Sends offer ‚Üí Driver via realtime/WebSockets.
6. Driver accepts:
   - matching service updates **Driver‚ÄìOrder mapping** atomically.
7. Notification service updates customer with driver + ETA.

If driver rejects/timeouts:
- mapping cleared  
- next driver chosen  

---

# 6 ‚Äî Driver Connectivity & Location Updating

### **Realtime Layer**
- Drivers maintain **WebSocket sessions**.

### **Driver Location Store**
- Stores live (lat, lon) for online drivers.
- Only active drivers are stored.
- Updated frequently but with **client-side throttling** to reduce write volume:
  - send updates only on significant movement

### **Geo-Sharding**
- Location store is sharded by:
  - city  
  - region  
  - or geo-tiles  
- Matching service only queries relevant shards.

---

# 7 ‚Äî Single Driver Assignment & State Management

### **Driver‚ÄìOrder Mapping Store**
- Small, fast, atomic key-value store.
- Ensures:
  - one driver per order  
  - one active order per driver (simplified model)

### **Assignment Safety**
Before assigning:
1. Check mapping store ‚Üí is order already assigned?
2. If not ‚Üí atomically set order‚Üídriver mapping.

Prevents:
- race conditions  
- double assignments  
- inconsistencies between services  

---

# 8 ‚Äî Optimizations & Scaling Notes

- **Search latency**  
  - Elasticsearch + tuned reindex frequency.

- **Driver location writes**  
  - Client-side thresholding ‚Üí fewer writes.

- **Sharding**  
  - Geo-shard driver store & menu DB.

- **Microservices scaling**  
  - Autoscale search independently from payments or matching.

- **Sync vs async**  
  - Sync for payment/order consistency.  
  - Async for notifications & search reindexing.  

---

# üîç All ‚ÄúWhy‚Äù Q&A (Detailed Explanations)

---

### **Why focus on Search, Driver Matching, Payments?**
They are core flows of food delivery:
- Search ‚Üí discovery  
- Matching ‚Üí fulfillment  
- Payments ‚Üí revenue  
Each has unique consistency & latency needs.

---

### **Why microservices?**
- Independent scaling  
- Independent deployment  
- Different SLAs for search vs. payments  
- Failure isolation  
- Easier regional sharding  

---

### **Why NoSQL for menus?**
- Flexible schema for semi-structured menu data  
- Horizontal scalability  
- Strong consistency is not critical here  

---

### **Why Elasticsearch for search?**
- Very low latency  
- Full-text search  
- Filtering & scoring  
- Better relevance models than DB queries  

---

### **Why accept eventual consistency in search?**
- Menus don‚Äôt change every minute  
- Reindexing continuously is expensive  
- Small staleness is tolerable  
- Can set SLA for freshness (e.g., <5 min)  

---

### **Why SQL for Order DB?**
- Money-related state ‚Üí must be correct  
- ACID transactions ensure:
  - no double charges  
  - consistent order state  

---

### **Why are payments synchronous?**
- Restaurant must not prepare food before payment is confirmed  
- Customer must know instantly if the payment succeeded  

---

### **Why use Stripe/third-party for payments?**
- No PCI-DSS burden  
- Faster development  
- Highly reliable fraud detection  
- Simplifies compliance  

---

### **Why idempotency keys?**
- Client retries during network issues  
- Prevents:
  - duplicate charges  
  - duplicate order creation  

---

### **Why WebSockets for drivers?**
- Low latency push notifications  
- Reliable session for:
  - offers  
  - cancellations  
  - updates  
- Polling is wasteful & slow  

---

### **Why store driver location frequently?**
- Needed for accurate driver matching  
- Enables fast proximity filtering  

---

### **Why throttle location updates?**
- Reduce backend writes & cost  
- Prevent unnecessary updates when stationary  

---

### **Why geo-shard driver location store?**
- Matching queries only need local drivers  
- Improves performance & reduces cross-region traffic  

---

### **Why keep only online drivers in store?**
- Offline drivers are irrelevant for matching  
- Reduces memory & DB load  

---

### **Why a separate driver‚Üîorder mapping store?**
- Fast atomic checks  
- Avoids double assignment  
- Avoids expensive DB joins  

---

### **Why strong consistency for driver assignment?**
- Two drivers showing up for the same order is catastrophic  
- Must enforce exactly-one assignment  

---

### **Why atomic updates during assignment?**
- Prevent race conditions  
- Multiple matching workers cannot assign at the same time  

---

### **Why async for notifications & reindexing?**
- They don‚Äôt block the critical path  
- Improves throughput  
- Avoids slowing down search or payments  

---

### **Why tune reindex freshness SLA?**
- Menus change infrequently  
- Helps optimize cost vs. freshness  

---

### **Why limit each driver to one order (in simplified design)?**
- Avoid routing complexity  
- Simpler ETA calculations  
- Easier correctness guarantees  

---

# ‚úÖ End of Markdown Document
